// @version=5
indicator("Susan", "", overlay = true)

// general settings
var offset = -1

var previousPeak = high
var previousPeakTime = time
var currentPeak = high
var currentPeakTime = time
var peakLine = line.new(x1 = 0, y1 = 0, x2 = 0, y2 = 0)

calcPeaks(high) =>
    if ((high[2] < high[1] and high[0] < high[1]) or (high[3] < high[2] and high[2] == high[1] and high[0] < high[1]) or (high[4] < high[3] and high[3] == high[1] and high[2] == high[1] and high[0] < high[1]))
        high[1]
    else
        na

peaksV = calcPeaks(high)

if (peaksV)
    peaksV := high[1]
    // track the previous and current peak
    previousPeak := currentPeak
    previousPeakTime := currentPeakTime
    currentPeak := high[1]
    currentPeakTime := time[1]

plot(peaksV, title='Peaks', color=color.new(color.yellow, 0), linewidth=3, style=plot.style_circles, offset = -1)

// example of when a peak is lower than the previous peak we delete any old lines and draw a new line connecting them
if (currentPeak < previousPeak)
    line.delete(peakLine)
    peakLine := line.new(x1 = previousPeakTime, y1 = previousPeak, x2 = currentPeakTime, y2 = currentPeak, xloc = xloc.bar_time, extend = extend.right)
    line.set_color(id = peakLine, color = color.yellow)
else
    line.delete(peakLine)

// VALLEYS

var previousValley = low
var previousValleyTime = time
var currentValley = low
var currentValleyTime = time
var valleyLine = line.new(x1 = 0, y1 = 0, x2 = 0, y2 = 0)

calcValley(low) =>
    if (low[2] > low[1] and low[0] > low[1])
        low[1]
    else
        na

valleyV = calcValley(low)

if (valleyV)
    valleyV := low[1]
    // track the previous and current valley
    previousValley := currentValley
    previousValleyTime := currentValleyTime
    currentValley := low[1]
    currentValleyTime := time[1]


plot(valleyV, title='Valley', color=color.new(color.orange, 0), linewidth=3, style=plot.style_circles, offset = -1)

// example of when a peak is lower than the previous peak we delete any old lines and draw a new line connecting them
if (currentValley > previousValley)
    line.delete(valleyLine)
    valleyLine := line.new(x1 = previousValleyTime, y1 = previousValley, x2 = currentValleyTime, y2 = currentValley, xloc = xloc.bar_time, extend = extend.right)
    line.set_color(id = valleyLine, color = color.orange)
else
    line.delete(valleyLine)


// DAILY PEAKS
// To avoid differences on historical and realtime bars, you can use this technique, which only returns a value from the higher timeframe on the bar after it completes:
indexHighTF = barstate.isrealtime ? 1 : 0
indexCurrTF = barstate.isrealtime ? 0 : 1

var float previousDailyPeak = na
var int previousDailyPeakTime = na
var float currentDailyPeak = na
var int currentDailyPeakTime = na
var dailyPeakLine = line.new(x1 = 0, y1 = 0, x2 = 0, y2 = 0)

[peaks1D, valley1D, time1D] = request.security(syminfo.tickerid, "D", [calcPeaks(high[indexHighTF]), calcValley(low[indexHighTF]), time[indexHighTF]], barmerge.gaps_on)

// if barstate.islastconfirmedhistory
//     label.new(bar_index, high, "OHLC values: " + str.tostring(valley1D))

if (peaks1D)
    previousDailyPeak := currentDailyPeak
    previousDailyPeakTime := previousDailyPeakTime
    currentDailyPeak := peaks1D
    currentDailyPeakTime := time1D

// TODO: I think the offset here needs to be -x amount of time that makes up 1 day.. like a multiplier
// Ex: 4hr would be -2... 1hr would be -8..
plot(peaks1D, title='Valley Daily', color=color.new(color.blue, 0), linewidth=3, style=plot.style_circles, offset = -8)

if (previousDailyPeak > currentDailyPeak)
    line.delete(dailyPeakLine)
    dailyPeakLine := line.new(x1 = previousDailyPeakTime, y1 = previousDailyPeak, x2 = currentDailyPeakTime, y2 = currentDailyPeak, xloc = xloc.bar_time, extend = extend.right)
    line.set_color(id = dailyPeakLine, color = color.blue)
else
    line.delete(dailyPeakLine)
